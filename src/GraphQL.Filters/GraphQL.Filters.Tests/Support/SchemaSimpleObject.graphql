schema {
  query: QueryType
}

type QueryType {
  simpleObjects(filter: FilterGraphTypeSimpleObject): [SimpleObject]
  nestedObjects(filter: FilterGraphTypeNestedObject): [NestedObject]
}

type NestedObject {
  stringMember: String!
  simples: [SimpleObject!]!
}

type SimpleObject {
  stringMember: String!
  intMember: Int!
  dateTimeMember: DateTime!
  dateOnlyMember: DateOnly!
  timeOnlyMember: TimeOnly!
  decimalMember: Decimal!
}

"The `DateTime` scalar type represents a date and time. `DateTime` expects timestamps to be formatted in accordance with the [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) standard."
scalar DateTime

"The `Date` scalar type represents a year, month and day in accordance with the [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) standard. Format is `yyyy-MM-dd`"
scalar DateOnly

"The `Time` scalar type represents a time in accordance with the [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) standard. Format is `HH:mm:ss.FFFFFFF`."
scalar TimeOnly

scalar Decimal

"only use one of the fields and leave the rest empty. Don't combine"
input FilterGraphTypeSimpleObject {
  condition: ConditionGraphTypeSimpleObject
  and: AndGraphTypeSimpleObject
  or: OrGraphTypeSimpleObject
  not: NotGraphTypeSimpleObject
}

"valid combinations are fieldname,operator,value  or filter, other combinations are invalid"
input ConditionGraphTypeSimpleObject {
  fieldName: FieldEnumerationGraphTypeSimpleObject
  operator: BinaryCompareEnumTypes
  value: ValueScalar
  filter: FilterGraphTypeSimpleObject
}

enum FieldEnumerationGraphTypeSimpleObject {
  StringMember
  IntMember
  DateTimeMember
  DateOnlyMember
  TimeOnlyMember
  DecimalMember
  StringField
}

enum BinaryCompareEnumTypes {
  equal
  greater
  greaterOrEqual
  less
  lessOrEqual
  notEqual
}

scalar ValueScalar

input AndGraphTypeSimpleObject {
  left: FilterGraphTypeSimpleObject!
  right: FilterGraphTypeSimpleObject!
}

input OrGraphTypeSimpleObject {
  left: FilterGraphTypeSimpleObject!
  right: FilterGraphTypeSimpleObject!
}

input NotGraphTypeSimpleObject {
  filter: FilterGraphTypeSimpleObject!
}

input FilterGraphTypeNestedObject {
  condition: ConditionGraphTypeNestedObject
  and: AndGraphTypeNestedObject
  or: OrGraphTypeNestedObject
  not: NotGraphTypeNestedObject
  any: AnyGraphTypeNestedObject
}

"valid combinations are fieldname,operator,value"
input ConditionGraphTypeNestedObject {
  fieldName: FieldEnumerationGraphTypeNestedObject
  operator: BinaryCompareEnumTypes
  value: ValueScalar
}

enum FieldEnumerationGraphTypeNestedObject {
  StringMember
  Simples
}

input AndGraphTypeNestedObject {
  left: FilterGraphTypeNestedObject!
  right: FilterGraphTypeNestedObject!
}

input OrGraphTypeNestedObject {
  left: FilterGraphTypeNestedObject!
  right: FilterGraphTypeNestedObject!
}

input NotGraphTypeNestedObject {
  filter: FilterGraphTypeNestedObject!
}

input AnyGraphTypeNestedObject {
  simples: FilterGraphTypeSimpleObject
}